#include "header.h"
double s3, s4, s41, s42, d3, d4, x, S2 = 0, C2;
extern double S1 = 0;
double int2(double a, double b, double c, double n) {
	x = a;
	d3 = fabs(a - b) / 2;
	d4 = d3 / 2;
	while (x < b) {
		if (sin(1 / x) < sin(1 / (x + d3))) { // из значения функции от y и y+d3 выбирается наименьшее (метод нижних
			s3 = d3*sin(1 / x); // прямоугольников)
			S1 += s3;
			if (sin(1 / x) < sin(1 / (x + d4))) { // для удвоенного числа разбиений наименьшее значение функции вычисляется 
				s41 = d4*sin(1 / x); // дважды, т.к. промежуточное значение с удвоенным разбиением должно состоять из 2 
			} // прямоугольников
			else {
				s41 = d4*sin(1 / (x + d4)); // площадь 1 прямоугольника
			}
			if (sin(1 / (x + d4)) < sin(1 / (x + 2 * d4))) {
				s42 = d4*sin(1 / (x + d4));
			}
			else {
				s42 = d4*sin(1 / (x + 2 * d4));// площадь 2 прямоугольника
			}
			s4 = s41 + s42; // промежуточное значение вычисленное с удвоенным разбиением
			S2 += s4;
		}
		else { 
			s3 = d3*sin(1 / (x + d3));
			S1 += s3;
			if (sin(1 / x) < sin(1 / (x + d4))) {
				s41 = d4*sin(1 / x);
			}
			else {
				s41 = d4*sin(1 / (x + d4));
			}
			if (sin(1 / (x + d4)) < sin(1 / (x + 2 * d4))) {
				s42 = d4*sin(1 / (x + d4));
			}
			else {
				s42 = d4*sin(1 / (x + 2 * d4));
			}
			s4 = s41 + s42;
			S2 += s4;
		}
		while (fabs(S1 - S2) > c) { // пока нужная точность не будет достигнута, будет пересчитываться последнее промежуточное значение
			S1 -= s3;
			S2 -= s4;
			d3 = d4;
			d4 = d4 / 2;// на каждой итерации число разбиений удваивается
			if (sin(1 / x) < sin(1 / (x + d3))) {
				s3 = d3*sin(1 / x);
				S1 += s3;
				if (sin(1 / x) < sin(1 / (x + d4))) {
					s41 = d4*sin(1 / x);
				}
				else {
					s41 = d4*sin(1 / (x + d4));
				}
				if (sin(1 / (x + d4)) < sin(1 / (x + 2 * d4))) {
					s42 = d4*sin(1 / (x + d4));
				}
				else {
					s42 = d4*sin(1 / (x + 2 * d4));
				}
				s4 = s41 + s42;
				S2 += s4;
			}
			else {
				s3 = d3*sin(1 / (x + d3));
				S1 += s3;
				if (sin(1 / x) < sin(1 / (x + d4))) {
					s41 = d4*sin(1 / x);
				}
				else {
					s41 = d4*sin(1 / (x + d4));
				}
				if (sin(1 / (x + d4)) < sin(1 / (x + 2 * d4))) {
					s42 = d4*sin(1 / (x + d4));
				}
				else {
					s42 = d4*sin(1 / (x + 2 * d4));
				}
				s4 = s41 + s42;
				S2 += s4;
			}
		}
		x += d3;
	}
	C2 = fabs(S1 - S2); // расчет итоговой точности
	return S1;
}
